<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"service_task.js.html":{"id":"service_task.js.html","title":"Source: service/task.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: service/task.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * タスクサービス */ const factory = require(&quot;@chevre/factory&quot;); const createDebug = require(&quot;debug&quot;); const TaskFunctionsService = require(&quot;./taskFunctions&quot;); const debug = createDebug('sskts-domain:service:task'); exports.ABORT_REPORT_SUBJECT = 'Task aborted !!!'; /** * execute a task by taskName * タスク名でタスクをひとつ実行する * @param taskName タスク名 */ function executeByName(taskName) { return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { // 未実行のタスクを取得 let task = null; try { task = yield settings.taskRepo.executeOneByName(taskName); debug('task found', task); } catch (error) { debug('executeByName error:', error); } // タスクがなければ終了 if (task !== null) { yield execute(task)(settings); } }); } exports.executeByName = executeByName; /** * execute a task * タスクを実行する * @param task タスクオブジェクト * @export */ function execute(task) { debug('executing a task...', task); const now = new Date(); return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { try { // タスク名の関数が定義されていなければ、TypeErrorとなる yield TaskFunctionsService[task.name](task.data)(settings); const result = { executedAt: now, error: '' }; yield settings.taskRepo.pushExecutionResultById(task.id, factory.taskStatus.Executed, result); } catch (error) { // 実行結果追加 const result = { executedAt: now, error: error.stack }; // 失敗してもここではステータスを戻さない(Runningのまま待機) yield settings.taskRepo.pushExecutionResultById(task.id, task.status, result); } }); } exports.execute = execute; /** * retry tasks in running status * 実行中ステータスのままになっているタスクをリトライする * @param intervalInMinutes 最終トライ日時から何分経過したタスクをリトライするか * @export */ function retry(intervalInMinutes) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { yield repos.task.retry(intervalInMinutes); }); } exports.retry = retry; /** * abort a task * トライ可能回数が0に達したタスクを実行中止する * @param intervalInMinutes 最終トライ日時から何分経過したタスクを中止するか * @export */ function abort(intervalInMinutes) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const abortedTask = yield repos.task.abortOne(intervalInMinutes); debug('abortedTask found', abortedTask); // 開発者へ報告 const lastResult = (abortedTask.executionResults.length &gt; 0) ? abortedTask.executionResults[abortedTask.executionResults.length - 1].error : // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ ''; debug('reporting...', lastResult); // await NotificationService.report2developers( // ABORT_REPORT_SUBJECT, // `id:${abortedTask.id} // name:${abortedTask.name} // runsAt:${moment(abortedTask.runsAt).toISOString()} // lastTriedAt:${moment(&lt;Date&gt;abortedTask.lastTriedAt).toISOString()} // numberOfTried:${abortedTask.numberOfTried} // lastResult:${lastResult}` // )(); }); } exports.abort = abort; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repository.js.html":{"id":"repository.js.html","title":"Source: repository.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repository.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); // tslint:disable:max-classes-per-file completed-docs /** * リポジトリー */ const action_1 = require(&quot;./repo/action&quot;); const event_1 = require(&quot;./repo/event&quot;); const screeningEvent_1 = require(&quot;./repo/itemAvailability/screeningEvent&quot;); const place_1 = require(&quot;./repo/place&quot;); const reservation_1 = require(&quot;./repo/reservation&quot;); const reservationNumber_1 = require(&quot;./repo/reservationNumber&quot;); const task_1 = require(&quot;./repo/task&quot;); const ticketType_1 = require(&quot;./repo/ticketType&quot;); const transaction_1 = require(&quot;./repo/transaction&quot;); class Action extends action_1.MongoRepository { } exports.Action = Action; class Event extends event_1.MongoRepository { } exports.Event = Event; class Place extends place_1.MongoRepository { } exports.Place = Place; class Reservation extends reservation_1.MongoRepository { } exports.Reservation = Reservation; class ReservationNumber extends reservationNumber_1.RedisRepository { } exports.ReservationNumber = ReservationNumber; class Task extends task_1.MongoRepository { } exports.Task = Task; class TicketType extends ticketType_1.MongoRepository { } exports.TicketType = TicketType; class Transaction extends transaction_1.MongoRepository { } exports.Transaction = Transaction; var itemAvailability; (function (itemAvailability) { class ScreeningEvent extends screeningEvent_1.RedisRepository { } itemAvailability.ScreeningEvent = ScreeningEvent; })(itemAvailability = exports.itemAvailability || (exports.itemAvailability = {})); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"service_reserve.js.html":{"id":"service_reserve.js.html","title":"Source: service/reserve.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: service/reserve.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 予約サービス */ const factory = require(&quot;@chevre/factory&quot;); const createDebug = require(&quot;debug&quot;); const debug = createDebug('chevre-domain:*'); /** * 予約を確定する */ function confirmReservation(actionAttributesList) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { yield Promise.all(actionAttributesList.map((actionAttributes) =&gt; __awaiter(this, void 0, void 0, function* () { // アクション開始 const action = yield repos.action.start(actionAttributes); try { // 予約を確定状態に変更する yield repos.reservation.confirm({ id: actionAttributes.object.id }); } catch (error) { // actionにエラー結果を追加 try { const actionError = Object.assign({}, error, { message: error.message, name: error.name }); yield repos.action.giveUp(action.typeOf, action.id, actionError); } catch (__) { // 失敗したら仕方ない } throw error; } // アクション完了 const actionResult = {}; yield repos.action.complete(action.typeOf, action.id, actionResult); }))); }); } exports.confirmReservation = confirmReservation; /** * 進行中の予約をキャンセルする */ function cancelPendingReservation(params) { return (_) =&gt; __awaiter(this, void 0, void 0, function* () { debug('canceling pending reservations...', params); }); } exports.cancelPendingReservation = cancelPendingReservation; /** * 予約をキャンセルする */ function cancelReservation(actionAttributesList) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const cancelReservationTransaction = yield repos.transaction.findById(factory.transactionType.CancelReservation, actionAttributesList[0].purpose.id); debug('canceling reservations...', actionAttributesList); yield Promise.all(actionAttributesList.map((actionAttributes) =&gt; __awaiter(this, void 0, void 0, function* () { // アクション開始 const action = yield repos.action.start(actionAttributes); try { // 予約をキャンセル状態に変更する const reservation = actionAttributes.object; yield repos.reservation.cancel({ id: reservation.id }); // 予約取引がまだ座席を保持していれば座席ロック解除 const lockKey = { eventId: reservation.reservationFor.id, offer: { seatNumber: reservation.reservedTicket.ticketedSeat.seatNumber, seatSection: reservation.reservedTicket.ticketedSeat.seatSection } }; const holder = yield repos.eventAvailability.getHolder(lockKey); if (holder === cancelReservationTransaction.object.transaction.id) { yield repos.eventAvailability.unlock(lockKey); } } catch (error) { // actionにエラー結果を追加 try { const actionError = Object.assign({}, error, { message: error.message, name: error.name }); yield repos.action.giveUp(action.typeOf, action.id, actionError); } catch (__) { // 失敗したら仕方ない } throw error; } // アクション完了 const actionResult = {}; yield repos.action.complete(action.typeOf, action.id, actionResult); }))); }); } exports.cancelReservation = cancelReservation; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"service_transaction_cancelReservation.js.html":{"id":"service_transaction_cancelReservation.js.html","title":"Source: service/transaction/cancelReservation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: service/transaction/cancelReservation.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 予約キャンセル取引サービス */ const createDebug = require(&quot;debug&quot;); const factory = require(&quot;@chevre/factory&quot;); const debug = createDebug('chevre-domain:*'); /** * 取引開始 */ function start(params) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { debug('starting transaction...', params); // 予約取引存在確認 const reserveTransaction = yield repos.transaction.findById(factory.transactionType.Reserve, params.object.transaction.id); const startParams = { typeOf: factory.transactionType.CancelReservation, agent: params.agent, object: { clientUser: params.object.clientUser, transaction: reserveTransaction }, expires: params.expires }; // 取引作成 let transaction; try { transaction = yield repos.transaction.start(factory.transactionType.CancelReservation, startParams); } catch (error) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ if (error.name === 'MongoError') { // no op } throw error; } // tslint:disable-next-line:no-suspicious-comment // TODO 予約ホールド // await Promise.all(reservations.map(async (r) =&gt; { // await repos.reservation.reservationModel.create({ ...r, _id: r.id }); // })); return transaction; }); } exports.start = start; /** * 取引確定 */ function confirm(params) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { debug(`confirming reserve transaction ${params.transactionId}...`); // 取引存在確認 const transaction = yield repos.transaction.findById(factory.transactionType.CancelReservation, params.transactionId); const reserveTransaction = transaction.object.transaction; // 予約アクション属性作成 const cancelReservationActionAttributes = reserveTransaction.object.reservations.map((r) =&gt; { return { typeOf: factory.actionType.CancelAction, // description: transaction.object.notes, result: {}, object: r, agent: transaction.agent, purpose: { typeOf: transaction.typeOf, id: transaction.id } }; }); const potentialActions = { cancelReservation: cancelReservationActionAttributes }; // 取引確定 const result = {}; yield repos.transaction.confirm(factory.transactionType.CancelReservation, transaction.id, result, potentialActions); }); } exports.confirm = confirm; /** * ひとつの取引のタスクをエクスポートする */ function exportTasks(status) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const transaction = yield repos.transaction.startExportTasks(factory.transactionType.CancelReservation, status); if (transaction === null) { return; } // 失敗してもここでは戻さない(RUNNINGのまま待機) yield exportTasksById(transaction.id)(repos); yield repos.transaction.setTasksExportedById(transaction.id); }); } exports.exportTasks = exportTasks; /** * ID指定で取引のタスク出力 */ function exportTasksById(transactionId) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const transaction = yield repos.transaction.findById(factory.transactionType.CancelReservation, transactionId); const potentialActions = transaction.potentialActions; const taskAttributes = []; switch (transaction.status) { case factory.transactionStatusType.Confirmed: // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (potentialActions !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (potentialActions.cancelReservation !== undefined) { const cancelReservationTask = { name: factory.taskName.CancelReservation, status: factory.taskStatus.Ready, runsAt: new Date(), remainingNumberOfTries: 10, lastTriedAt: null, numberOfTried: 0, executionResults: [], data: { actionAttributes: potentialActions.cancelReservation } }; taskAttributes.push(cancelReservationTask); } } break; case factory.transactionStatusType.Canceled: case factory.transactionStatusType.Expired: // const cancelMoneyTransferTask: factory.task.cancelMoneyTransfer.IAttributes = { // name: factory.taskName.CancelMoneyTransfer, // status: factory.taskStatus.Ready, // runsAt: new Date(), // なるはやで実行 // remainingNumberOfTries: 10, // lastTriedAt: null, // numberOfTried: 0, // executionResults: [], // data: { // transaction: { typeOf: transaction.typeOf, id: transaction.id } // } // }; // taskAttributes.push(cancelMoneyTransferTask); break; default: throw new factory.errors.NotImplemented(`Transaction status &quot;${transaction.status}&quot; not implemented.`); } debug('taskAttributes prepared', taskAttributes); return Promise.all(taskAttributes.map((a) =&gt; __awaiter(this, void 0, void 0, function* () { return repos.task.save(a); }))); }); } exports.exportTasksById = exportTasksById; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"service_transaction_reserve.js.html":{"id":"service_transaction_reserve.js.html","title":"Source: service/transaction/reserve.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: service/transaction/reserve.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 予約取引サービス */ const createDebug = require(&quot;debug&quot;); const factory = require(&quot;@chevre/factory&quot;); const debug = createDebug('chevre-domain:*'); /** * 取引開始 */ // tslint:disable-next-line:max-func-body-length function start(params) { // tslint:disable-next-line:max-func-body-length return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { debug('starting transaction...', params); const now = new Date(); // イベント存在確認 const screeningEvent = yield repos.event.findById({ typeOf: factory.eventType.ScreeningEvent, id: params.object.event.id }); // チケット存在確認 const ticketTypes = yield repos.ticketType.findByTicketGroupId({ ticketGroupId: screeningEvent.ticketTypeGroup }); debug('available ticket type:', ticketTypes); // 予約番号発行 const reservationNumber = yield repos.reservationNumber.publish({ reserveDate: now, sellerBranchCode: screeningEvent.superEvent.location.branchCode }); // 取引ファクトリーで新しい進行中取引オブジェクトを作成 const tickets = params.object.tickets.map((ticket) =&gt; { const ticketType = ticketTypes.find((t) =&gt; t.id === ticket.ticketType.id); if (ticketType === undefined) { throw new factory.errors.NotFound('Ticket type'); } return { typeOf: 'Ticket', dateIssued: now, issuedBy: { typeOf: screeningEvent.location.typeOf, name: screeningEvent.location.name.ja }, totalPrice: ticketType.charge, priceCurrency: factory.priceCurrency.JPY, ticketedSeat: ticket.ticketedSeat, underName: { typeOf: params.agent.typeOf, name: params.agent.name }, ticketType: ticketType }; }); // 仮予約作成 const reservations = yield Promise.all(tickets.map((ticket, index) =&gt; __awaiter(this, void 0, void 0, function* () { return createReservation({ id: `${reservationNumber}-${index}`, reserveDate: now, agent: params.agent, reservationNumber: reservationNumber, screeningEvent: screeningEvent, reservedTicket: ticket }); }))); const startParams = { typeOf: factory.transactionType.Reserve, agent: params.agent, object: { clientUser: params.object.clientUser, event: screeningEvent, reservations: reservations, notes: params.object.notes }, expires: params.expires }; // 取引作成 let transaction; try { transaction = yield repos.transaction.start(factory.transactionType.Reserve, startParams); } catch (error) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ if (error.name === 'MongoError') { // no op } throw error; } // 座席ロック yield repos.eventAvailability.lock({ eventId: screeningEvent.id, offers: tickets.map((ticket) =&gt; { return { seatSection: ticket.ticketedSeat.seatSection, seatNumber: ticket.ticketedSeat.seatNumber }; }), expires: screeningEvent.endDate, holder: transaction.id }); // 予約作成 yield Promise.all(reservations.map((r) =&gt; __awaiter(this, void 0, void 0, function* () { yield repos.reservation.reservationModel.create(Object.assign({}, r, { _id: r.id })); }))); return transaction; }); } exports.start = start; function createReservation(params) { return { typeOf: factory.reservationType.EventReservation, id: params.id, additionalTicketText: params.reservedTicket.ticketType.name.ja, modifiedTime: params.reserveDate, numSeats: 1, price: params.reservedTicket.ticketType.charge, priceCurrency: factory.priceCurrency.JPY, reservationFor: params.screeningEvent, reservationNumber: params.reservationNumber, reservationStatus: factory.reservationStatusType.ReservationPending, reservedTicket: params.reservedTicket, underName: params.agent }; } /** * 取引確定 */ function confirm(params) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { debug(`confirming reserve transaction ${params.transactionId}...`); // 取引存在確認 const transaction = yield repos.transaction.findById(factory.transactionType.Reserve, params.transactionId); // 予約アクション属性作成 const reserveActionAttributes = transaction.object.reservations.map((r) =&gt; { return { typeOf: factory.actionType.ReserveAction, description: transaction.object.notes, result: {}, object: r, agent: transaction.agent, purpose: { typeOf: transaction.typeOf, id: transaction.id } }; }); const potentialActions = { reserve: reserveActionAttributes }; // 取引確定 const result = {}; yield repos.transaction.confirm(factory.transactionType.Reserve, transaction.id, result, potentialActions); }); } exports.confirm = confirm; /** * ひとつの取引のタスクをエクスポートする */ function exportTasks(status) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const transaction = yield repos.transaction.startExportTasks(factory.transactionType.Reserve, status); if (transaction === null) { return; } // 失敗してもここでは戻さない(RUNNINGのまま待機) yield exportTasksById(transaction.id)(repos); yield repos.transaction.setTasksExportedById(transaction.id); }); } exports.exportTasks = exportTasks; /** * ID指定で取引のタスク出力 */ function exportTasksById(transactionId) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const transaction = yield repos.transaction.findById(factory.transactionType.Reserve, transactionId); const potentialActions = transaction.potentialActions; const taskAttributes = []; switch (transaction.status) { case factory.transactionStatusType.Confirmed: // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (potentialActions !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (potentialActions.reserve !== undefined) { const reserveTask = { name: factory.taskName.Reserve, status: factory.taskStatus.Ready, runsAt: new Date(), remainingNumberOfTries: 10, lastTriedAt: null, numberOfTried: 0, executionResults: [], data: { actionAttributes: potentialActions.reserve } }; taskAttributes.push(reserveTask); } } break; case factory.transactionStatusType.Canceled: case factory.transactionStatusType.Expired: // const cancelMoneyTransferTask: factory.task.cancelMoneyTransfer.IAttributes = { // name: factory.taskName.CancelMoneyTransfer, // status: factory.taskStatus.Ready, // runsAt: new Date(), // なるはやで実行 // remainingNumberOfTries: 10, // lastTriedAt: null, // numberOfTried: 0, // executionResults: [], // data: { // transaction: { typeOf: transaction.typeOf, id: transaction.id } // } // }; // taskAttributes.push(cancelMoneyTransferTask); break; default: throw new factory.errors.NotImplemented(`Transaction status &quot;${transaction.status}&quot; not implemented.`); } debug('taskAttributes prepared', taskAttributes); return Promise.all(taskAttributes.map((a) =&gt; __awaiter(this, void 0, void 0, function* () { return repos.task.save(a); }))); }); } exports.exportTasksById = exportTasksById; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_mongoose_schemaTypes_multilingualString.js.html":{"id":"repo_mongoose_schemaTypes_multilingualString.js.html","title":"Source: repo/mongoose/schemaTypes/multilingualString.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/mongoose/schemaTypes/multilingualString.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 多言語文字列mongooseスキーマタイプ */ exports.default = { en: { type: String, required: false }, ja: { type: String, required: false }, kr: { type: String, required: false } }; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: index.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * index module */ const factory = require(&quot;@chevre/factory&quot;); const mongoose = require(&quot;mongoose&quot;); const redis = require(&quot;redis&quot;); const repository = require(&quot;./repository&quot;); const service = require(&quot;./service&quot;); /** * MongoDBクライアント`mongoose` * @example * const promise = domain.mongoose.connect('mongodb://localhost/myapp', { * useMongoClient: true * }); */ exports.mongoose = mongoose; /** * Redis Cacheクライアント * @example * const client = domain.redis.createClient({ * host: process.env.REDIS_HOST, * port: process.env.REDIS_PORT, * password: process.env.REDIS_KEY, * tls: { servername: process.env.REDIS_HOST } * }); */ exports.redis = redis; exports.factory = factory; exports.repository = repository; exports.service = service; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"service_taskFunctions.js.html":{"id":"service_taskFunctions.js.html","title":"Source: service/taskFunctions.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: service/taskFunctions.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * タスクファンクションサービス * タスク名ごとに、実行するファンクションをひとつずつ定義しています */ const factory = require(&quot;@chevre/factory&quot;); const action_1 = require(&quot;../repo/action&quot;); const screeningEvent_1 = require(&quot;../repo/itemAvailability/screeningEvent&quot;); const reservation_1 = require(&quot;../repo/reservation&quot;); const transaction_1 = require(&quot;../repo/transaction&quot;); const ReserveService = require(&quot;./reserve&quot;); function cancelReservation(data) { return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { if (settings.redisClient === undefined) { throw new factory.errors.Argument('settings', 'redisClient required'); } const actionRepo = new action_1.MongoRepository(settings.connection); const reservationRepo = new reservation_1.MongoRepository(settings.connection); const transactionRepo = new transaction_1.MongoRepository(settings.connection); const eventAvailabilityRepo = new screeningEvent_1.RedisRepository(settings.redisClient); yield ReserveService.cancelReservation(data.actionAttributes)({ action: actionRepo, reservation: reservationRepo, transaction: transactionRepo, eventAvailability: eventAvailabilityRepo }); }); } exports.cancelReservation = cancelReservation; function reserve(data) { return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { const actionRepo = new action_1.MongoRepository(settings.connection); const reservationRepo = new reservation_1.MongoRepository(settings.connection); yield ReserveService.confirmReservation(data.actionAttributes)({ action: actionRepo, reservation: reservationRepo }); }); } exports.reserve = reserve; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"service_util.js.html":{"id":"service_util.js.html","title":"Source: service/util.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: service/util.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 都道府県リスト */ function getPrefectrues() { return [ { code: '01', name: { ja: '北海道', en: 'Hokkaido Government' } }, { code: '02', name: { ja: '青森県', en: 'Aomori Prefectural Government' } }, { code: '03', name: { ja: '岩手県', en: 'Iwate Prefectural Government' } }, { code: '04', name: { ja: '宮城県', en: 'Miyagi Prefectural Government' } }, { code: '05', name: { ja: '秋田県', en: 'Akita Prefecture' } }, { code: '06', name: { ja: '山形県', en: 'Yamagata Prefecture' } }, { code: '07', name: { ja: '福島県', en: 'Fukushima Prefecture' } }, { code: '08', name: { ja: '茨城県', en: 'Ibaraki Prefecture Government' } }, { code: '09', name: { ja: '栃木県', en: 'Tochigi Prefecture' } }, { code: '10', name: { ja: '群馬県', en: 'Gunma Prefecture' } }, { code: '11', name: { ja: '埼玉県', en: 'Saitama Prefectural Government' } }, { code: '12', name: { ja: '千葉県', en: 'Chiba Prefectural Government' } }, { code: '13', name: { ja: '東京都', en: 'Tokyo Metropolitan Government' } }, { code: '14', name: { ja: '神奈川県', en: 'Kanagawa Prefecture' } }, { code: '15', name: { ja: '新潟県', en: 'Niigata Prefecture' } }, { code: '16', name: { ja: '富山県', en: 'Toyama Prefecture' } }, { code: '17', name: { ja: '石川県', en: 'Ishikawa Prefecture' } }, { code: '18', name: { ja: '福井県', en: 'Fukui Prefectural Government' } }, { code: '19', name: { ja: '山梨県', en: 'Yamanashi Prefecture' } }, { code: '20', name: { ja: '長野県', en: 'Nagano Prefecture' } }, { code: '21', name: { ja: '岐阜県', en: 'Gifu Prefectural Government' } }, { code: '22', name: { ja: '静岡県', en: 'Shizuoka Prefecture' } }, { code: '23', name: { ja: '愛知県', en: 'Aichi Prefecture' } }, { code: '24', name: { ja: '三重県', en: 'Mie Prefecture' } }, { code: '25', name: { ja: '滋賀県', en: 'Shiga Prefecture' } }, { code: '26', name: { ja: '京都府', en: 'Kyoto Prefecture' } }, { code: '27', name: { ja: '大阪府', en: 'Osaka Prefectural Government' } }, { code: '28', name: { ja: '兵庫県', en: 'Hyogo Prefecture' } }, { code: '29', name: { ja: '奈良県', en: 'Nara Prefecture' } }, { code: '30', name: { ja: '和歌山県', en: 'Wakayama Prefecture' } }, { code: '31', name: { ja: '鳥取県', en: 'Tottori Prefecture' } }, { code: '32', name: { ja: '島根県', en: 'Shimane Prefectural Government' } }, { code: '33', name: { ja: '岡山県', en: 'Okayama Prefecture' } }, { code: '34', name: { ja: '広島県', en: 'Hiroshima Prefecture' } }, { code: '35', name: { ja: '山口県', en: 'Yamaguchi Prefecture' } }, { code: '36', name: { ja: '徳島県', en: 'Tokushima Prefecture' } }, { code: '37', name: { ja: '香川県', en: 'Kagawa Prefectural Government' } }, { code: '38', name: { ja: '愛媛県', en: 'Ehime Prefectural Government' } }, { code: '39', name: { ja: '高知県', en: 'Kochi Prefecture' } }, { code: '40', name: { ja: '福岡県', en: 'Fukuoka Prefecture' } }, { code: '41', name: { ja: '佐賀県', en: 'Saga Prefectural Government' } }, { code: '42', name: { ja: '長崎県', en: 'Nagasaki Prefecture' } }, { code: '43', name: { ja: '熊本県', en: 'Kumamoto Prefecture' } }, { code: '44', name: { ja: '大分県', en: 'Oita Prefecture' } }, { code: '45', name: { ja: '宮崎県', en: 'Miyazaki Prefecture' } }, { code: '46', name: { ja: '鹿児島県', en: 'Kagoshima Prefecture' } }, { code: '47', name: { ja: '沖縄県', en: 'Okinawa Prefecture' } } ]; } exports.getPrefectrues = getPrefectrues; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_transaction.js.html":{"id":"repo_transaction.js.html","title":"Source: repo/transaction.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/transaction.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const moment = require(&quot;moment&quot;); const transaction_1 = require(&quot;./mongoose/model/transaction&quot;); /** * 取引Mongoリポジトリー */ class MongoRepository { constructor(connection) { this.transactionModel = connection.model(transaction_1.default.modelName); } /** * 取引を開始する */ start(typeOf, params) { return __awaiter(this, void 0, void 0, function* () { return this.transactionModel.create(Object.assign({ typeOf: typeOf }, params, { status: factory.transactionStatusType.InProgress, startDate: new Date(), endDate: undefined, tasksExportationStatus: factory.transactionTasksExportationStatus.Unexported })).then((doc) =&gt; doc.toObject()); }); } /** * IDで取引を取得する */ findById(typeOf, /** * 取引ID */ transactionId) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.transactionModel.findOne({ _id: transactionId, typeOf: typeOf }).exec(); if (doc === null) { throw new factory.errors.NotFound('Transaction'); } return doc.toObject(); }); } /** * 取引を確定する */ confirm(typeOf, transactionId, result, potentialActions) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.transactionModel.findOneAndUpdate({ _id: transactionId, typeOf: typeOf, status: factory.transactionStatusType.InProgress }, { status: factory.transactionStatusType.Confirmed, endDate: new Date(), result: result, potentialActions: potentialActions }, { new: true }).exec(); // NotFoundであれば取引状態確認 if (doc === null) { const transaction = yield this.findById(typeOf, transactionId); if (transaction.status === factory.transactionStatusType.Confirmed) { // すでに確定済の場合 return transaction; } else if (transaction.status === factory.transactionStatusType.Expired) { throw new factory.errors.Argument('accountNumber', 'Transaction already expired'); } else if (transaction.status === factory.transactionStatusType.Canceled) { throw new factory.errors.Argument('accountNumber', 'Transaction already canceled'); } else { throw new factory.errors.NotFound('Transaction'); } } return doc.toObject(); }); } /** * 取引を中止する */ cancel(typeOf, transactionId) { return __awaiter(this, void 0, void 0, function* () { // 進行中ステータスの取引を中止する const doc = yield this.transactionModel.findOneAndUpdate({ typeOf: typeOf, _id: transactionId, status: factory.transactionStatusType.InProgress }, { status: factory.transactionStatusType.Canceled, endDate: new Date() }, { new: true }).exec(); // NotFoundであれば取引状態確認 if (doc === null) { const transaction = yield this.findById(typeOf, transactionId); if (transaction.status === factory.transactionStatusType.Canceled) { // すでに中止済の場合 return transaction; } else if (transaction.status === factory.transactionStatusType.Expired) { throw new factory.errors.Argument('accountNumber', 'Transaction already expired'); } else if (transaction.status === factory.transactionStatusType.Confirmed) { throw new factory.errors.Argument('accountNumber', 'Confirmed transaction unable to cancel'); } else { throw new factory.errors.NotFound('Transaction'); } } return doc.toObject(); }); } /** * タスク未エクスポートの取引をひとつ取得してエクスポートを開始する * @param typeOf 取引タイプ * @param status 取引ステータス */ startExportTasks(typeOf, status) { return __awaiter(this, void 0, void 0, function* () { return this.transactionModel.findOneAndUpdate({ typeOf: typeOf, status: status, tasksExportationStatus: factory.transactionTasksExportationStatus.Unexported }, { tasksExportationStatus: factory.transactionTasksExportationStatus.Exporting }, { new: true }).exec().then((doc) =&gt; (doc === null) ? null : doc.toObject()); }); } /** * タスクエクスポートリトライ * todo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ */ reexportTasks(intervalInMinutes) { return __awaiter(this, void 0, void 0, function* () { yield this.transactionModel.findOneAndUpdate({ tasksExportationStatus: factory.transactionTasksExportationStatus.Exporting, updatedAt: { $lt: moment().add(-intervalInMinutes, 'minutes').toISOString() } }, { tasksExportationStatus: factory.transactionTasksExportationStatus.Unexported }).exec(); }); } /** * set task status exported by transaction id * IDでタスクをエクスポート済に変更する * @param transactionId transaction id */ setTasksExportedById(transactionId) { return __awaiter(this, void 0, void 0, function* () { yield this.transactionModel.findByIdAndUpdate(transactionId, { tasksExportationStatus: factory.transactionTasksExportationStatus.Exported, tasksExportedAt: moment().toDate() }).exec(); }); } /** * 取引を期限切れにする */ makeExpired(params) { return __awaiter(this, void 0, void 0, function* () { // ステータスと期限を見て更新 yield this.transactionModel.update({ status: factory.transactionStatusType.InProgress, expires: { $lt: params.expires } }, { status: factory.transactionStatusType.Expired, endDate: new Date() }, { multi: true }).exec(); }); } /** * 取引を検索する * @param conditions 検索条件 */ search(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = { startDate: { $gte: params.startFrom, $lte: params.startThrough } }; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.typeOf !== undefined) { conditions.typeOf = params.typeOf; } return this.transactionModel.find(conditions).exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_task.js.html":{"id":"repo_task.js.html","title":"Source: repo/task.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/task.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const moment = require(&quot;moment&quot;); const task_1 = require(&quot;./mongoose/model/task&quot;); /** * タスク実行時のソート条件 * @const */ const sortOrder4executionOfTasks = { numberOfTried: 1, runsAt: 1 // 実行予定日時の早さ優先 }; /** * タスクレポジトリー */ class MongoRepository { constructor(connection) { this.taskModel = connection.model(task_1.default.modelName); } save(taskAttributes) { return __awaiter(this, void 0, void 0, function* () { return this.taskModel.create(taskAttributes).then((doc) =&gt; doc.toObject()); }); } executeOneByName(taskName) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.taskModel.findOneAndUpdate({ status: factory.taskStatus.Ready, runsAt: { $lt: new Date() }, name: taskName }, { status: factory.taskStatus.Running, lastTriedAt: new Date(), $inc: { remainingNumberOfTries: -1, numberOfTried: 1 // トライ回数増やす } }, { new: true }).sort(sortOrder4executionOfTasks).exec(); if (doc === null) { throw new factory.errors.NotFound('executable task'); } return doc.toObject(); }); } retry(intervalInMinutes) { return __awaiter(this, void 0, void 0, function* () { const lastTriedAtShoudBeLessThan = moment().add(-intervalInMinutes, 'minutes').toDate(); yield this.taskModel.update({ status: factory.taskStatus.Running, lastTriedAt: { $lt: lastTriedAtShoudBeLessThan }, remainingNumberOfTries: { $gt: 0 } }, { status: factory.taskStatus.Ready // 実行前に変更 }, { multi: true }).exec(); }); } abortOne(intervalInMinutes) { return __awaiter(this, void 0, void 0, function* () { const lastTriedAtShoudBeLessThan = moment().add(-intervalInMinutes, 'minutes').toDate(); const doc = yield this.taskModel.findOneAndUpdate({ status: factory.taskStatus.Running, lastTriedAt: { $lt: lastTriedAtShoudBeLessThan }, remainingNumberOfTries: 0 }, { status: factory.taskStatus.Aborted }, { new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('abortable task'); } return doc.toObject(); }); } pushExecutionResultById(id, status, executionResult) { return __awaiter(this, void 0, void 0, function* () { yield this.taskModel.findByIdAndUpdate(id, { status: status, $push: { executionResults: executionResult } }).exec(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_event.js.html":{"id":"repo_event.js.html","title":"Source: repo/event.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/event.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const moment = require(&quot;moment&quot;); const uniqid = require(&quot;uniqid&quot;); const event_1 = require(&quot;./mongoose/model/event&quot;); /** * イベントリポジトリー */ class MongoRepository { constructor(connection) { this.eventModel = connection.model(event_1.default.modelName); } /** * 上映イベントを保管する */ saveScreeningEventSeries(params) { return __awaiter(this, void 0, void 0, function* () { let event; if (params.id === undefined) { const id = uniqid(); const doc = yield this.eventModel.create(Object.assign({}, params.attributes, { _id: id })); event = doc.toObject(); } else { const doc = yield this.eventModel.findOneAndUpdate({ _id: params.id, typeOf: factory.eventType.ScreeningEventSeries }, params.attributes, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Event'); } event = doc.toObject(); } return event; }); } /** * 個々の上映イベントを保管する */ saveScreeningEvent(params) { return __awaiter(this, void 0, void 0, function* () { let event; if (params.id === undefined) { const id = uniqid(); const doc = yield this.eventModel.create(Object.assign({}, params.attributes, { _id: id })); event = doc.toObject(); } else { const doc = yield this.eventModel.findOneAndUpdate({ _id: params.id, typeOf: factory.eventType.ScreeningEvent }, params.attributes, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Event'); } event = doc.toObject(); } return event; }); } /** * 個々の上映イベントを検索する */ searchScreeningEvents(searchConditions) { return __awaiter(this, void 0, void 0, function* () { // dayプロパティがあればstartFrom &amp; startThroughに変換(互換性維持のため) // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.day !== undefined) { searchConditions.startFrom = moment(`${searchConditions.day} +09:00`, 'YYYYMMDD Z').toDate(); searchConditions.startThrough = moment(`${searchConditions.day} +09:00`, 'YYYYMMDD Z').add(1, 'day').toDate(); } // MongoDB検索条件 const andConditions = [ { typeOf: factory.eventType.ScreeningEvent } ]; // theaterプロパティがあればbranchCodeで検索(互換性維持のため) // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.theater !== undefined) { andConditions.push({ 'superEvent.location.branchCode': { $exists: true, $eq: searchConditions.theater } }); } // 場所の識別子条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.superEventLocationIds)) { andConditions.push({ 'superEvent.location.id': { $exists: true, $in: searchConditions.superEventLocationIds } }); } // イベントステータス条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.eventStatuses)) { andConditions.push({ eventStatus: { $in: searchConditions.eventStatuses } }); } // 作品識別子条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.workPerformedIds)) { andConditions.push({ 'workPerformed.id': { $in: searchConditions.workPerformedIds } }); } // 開始日時条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.startFrom !== undefined) { andConditions.push({ startDate: { $gte: searchConditions.startFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.startThrough !== undefined) { andConditions.push({ startDate: { $lt: searchConditions.startThrough } }); } // 終了日時条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.endFrom !== undefined) { andConditions.push({ endDate: { $gte: searchConditions.endFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.endThrough !== undefined) { andConditions.push({ endDate: { $lt: searchConditions.endThrough } }); } return yield this.eventModel.find({ $and: andConditions }) .sort({ startDate: 1 }) .setOptions({ maxTimeMS: 10000 }) .exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * 上映イベントを検索する */ searchScreeningEventSeries(searchConditions) { return __awaiter(this, void 0, void 0, function* () { // MongoDB検索条件 const andConditions = [ { typeOf: factory.eventType.ScreeningEvent } ]; // 場所の識別子条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.locationIds)) { andConditions.push({ 'location.id': { $exists: true, $in: searchConditions.locationIds } }); } // イベントステータス条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.eventStatuses)) { andConditions.push({ eventStatus: { $in: searchConditions.eventStatuses } }); } // 作品識別子条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.workPerformedIds)) { andConditions.push({ 'workPerformed.id': { $in: searchConditions.workPerformedIds } }); } // 開始日時条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.startFrom !== undefined) { andConditions.push({ startDate: { $gte: searchConditions.startFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.startThrough !== undefined) { andConditions.push({ startDate: { $lt: searchConditions.startThrough } }); } // 終了日時条件 // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.endFrom !== undefined) { andConditions.push({ endDate: { $gte: searchConditions.endFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (searchConditions.endThrough !== undefined) { andConditions.push({ endDate: { $lt: searchConditions.endThrough } }); } return yield this.eventModel.find({ $and: andConditions }) .sort({ startDate: 1 }) .setOptions({ maxTimeMS: 10000 }) .exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * IDでイベントを取得する */ findById(params) { return __awaiter(this, void 0, void 0, function* () { const event = yield this.eventModel.findOne({ typeOf: params.typeOf, _id: params.id }).exec(); if (event === null) { throw new factory.errors.NotFound('Event'); } return event.toObject(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_place.js.html":{"id":"repo_place.js.html","title":"Source: repo/place.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/place.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const createDebug = require(&quot;debug&quot;); const place_1 = require(&quot;./mongoose/model/place&quot;); const debug = createDebug('chevre-domain:*'); /** * 場所抽象リポジトリー */ class Repository { } exports.Repository = Repository; /** * 場所リポジトリー */ class MongoRepository { constructor(connection) { this.placeModel = connection.model(place_1.default.modelName); } /** * 劇場を保管する * @param movieTheater movieTheater object */ saveMovieTheater(movieTheater) { return __awaiter(this, void 0, void 0, function* () { yield this.placeModel.findOneAndUpdate({ branchCode: movieTheater.branchCode }, movieTheater, { upsert: true }).exec(); }); } /** * 劇場検索 * @param searchConditions 検索条件 */ searchMovieTheaters(searchConditions) { return __awaiter(this, void 0, void 0, function* () { // 検索条件を作成 const conditions = { typeOf: factory.placeType.MovieTheater }; debug('searchConditions:', searchConditions); // tslint:disable-next-line:no-suspicious-comment // TODO 検索条件を指定できるように改修 debug('finding places...', conditions); // containsPlaceを含めるとデータサイズが大きくなるので、検索結果には含めない return this.placeModel.find(conditions, { containsPlace: 0 }) .setOptions({ maxTimeMS: 10000 }) .exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * 枝番号で劇場検索 */ findMovieTheaterByBranchCode(branchCode) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.placeModel.findOne({ typeOf: factory.placeType.MovieTheater, branchCode: branchCode }).exec(); if (doc === null) { throw new factory.errors.NotFound('movieTheater'); } return doc.toObject(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_reservation.js.html":{"id":"repo_reservation.js.html","title":"Source: repo/reservation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/reservation.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const reservation_1 = require(&quot;./mongoose/model/reservation&quot;); /** * 予約リポジトリー */ class MongoRepository { constructor(connection) { this.reservationModel = connection.model(reservation_1.default.modelName); } /** * 上映イベント予約を検索する */ searchScreeningEventReservations(searchConditions) { return __awaiter(this, void 0, void 0, function* () { // MongoDB検索条件 const andConditions = [ { typeOf: factory.reservationType.EventReservation } ]; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.ids)) { andConditions.push({ _id: { $in: searchConditions.ids } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.reservationStatuses)) { andConditions.push({ reservationStatus: { $in: searchConditions.reservationStatuses } }); } return this.reservationModel.find({ $and: andConditions }, { __v: 0, createdAt: 0, updatedAt: 0 }) .sort({ createdAt: 1 }) .setOptions({ maxTimeMS: 10000 }) .exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } confirm(params) { return __awaiter(this, void 0, void 0, function* () { yield this.reservationModel.findByIdAndUpdate(params.id, { reservationStatus: factory.reservationStatusType.ReservationConfirmed, modifiedTime: new Date() }).exec().then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('Reservation'); } }); }); } cancel(params) { return __awaiter(this, void 0, void 0, function* () { yield this.reservationModel.findByIdAndUpdate(params.id, { reservationStatus: factory.reservationStatusType.ReservationCancelled, modifiedTime: new Date() }).exec().then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('Reservation'); } }); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_action.js.html":{"id":"repo_action.js.html","title":"Source: repo/action.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/action.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const createDebug = require(&quot;debug&quot;); const action_1 = require(&quot;./mongoose/model/action&quot;); const debug = createDebug('chevre-domain:*'); /** * アクションリポジトリー */ class MongoRepository { constructor(connection) { this.actionModel = connection.model(action_1.default.modelName); } /** * アクション開始 */ start(params) { return __awaiter(this, void 0, void 0, function* () { return this.actionModel.create(Object.assign({}, params, { actionStatus: factory.actionStatusType.ActiveActionStatus, startDate: new Date() })).then((doc) =&gt; doc.toObject()); }); } /** * アクション完了 */ complete(typeOf, actionId, result) { return __awaiter(this, void 0, void 0, function* () { return this.actionModel.findOneAndUpdate({ typeOf: typeOf, _id: actionId }, { actionStatus: factory.actionStatusType.CompletedActionStatus, result: result, endDate: new Date() }, { new: true }).exec().then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('action'); } return doc.toObject(); }); }); } /** * アクション中止 */ cancel(typeOf, actionId) { return __awaiter(this, void 0, void 0, function* () { return this.actionModel.findOneAndUpdate({ typeOf: typeOf, _id: actionId }, { actionStatus: factory.actionStatusType.CanceledActionStatus }, { new: true }).exec() .then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('action'); } return doc.toObject(); }); }); } /** * アクション失敗 */ giveUp(typeOf, actionId, error) { return __awaiter(this, void 0, void 0, function* () { return this.actionModel.findOneAndUpdate({ typeOf: typeOf, _id: actionId }, { actionStatus: factory.actionStatusType.FailedActionStatus, error: error, endDate: new Date() }, { new: true }).exec().then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('action'); } return doc.toObject(); }); }); } /** * IDで取得する */ findById(typeOf, actionId) { return __awaiter(this, void 0, void 0, function* () { return this.actionModel.findOne({ typeOf: typeOf, _id: actionId }).exec() .then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('action'); } return doc.toObject(); }); }); } /** * アクションを検索する * @param searchConditions 検索条件 */ search(searchConditions) { return __awaiter(this, void 0, void 0, function* () { const andConditions = [ { typeOf: searchConditions.typeOf }, { startDate: { $exists: true, $gte: searchConditions.startDateFrom, $lte: searchConditions.startDateThrough } } ]; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.actionStatuses) &amp;&amp; searchConditions.actionStatuses.length &gt; 0) { andConditions.push({ actionStatus: { $in: searchConditions.actionStatuses } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.purposeTypeOfs) &amp;&amp; searchConditions.purposeTypeOfs.length &gt; 0) { andConditions.push({ 'purpose.typeOf': { $exists: true, $in: searchConditions.purposeTypeOfs } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.fromLocationAccountNumbers) &amp;&amp; searchConditions.fromLocationAccountNumbers.length &gt; 0) { andConditions.push({ 'fromLocation.accountNumber': { $exists: true, $in: searchConditions.fromLocationAccountNumbers } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(searchConditions.toLocationAccountNumbers) &amp;&amp; searchConditions.toLocationAccountNumbers.length &gt; 0) { andConditions.push({ 'toLocation.accountNumber': { $exists: true, $in: searchConditions.toLocationAccountNumbers } }); } debug('finding actions...', andConditions); return this.actionModel.find({ $and: andConditions }, { __v: 0, createdAt: 0, updatedAt: 0 }) .sort({ _id: 1 }) .limit(searchConditions.limit) .exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_ticketType.js.html":{"id":"repo_ticketType.js.html","title":"Source: repo/ticketType.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/ticketType.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const ticketType_1 = require(&quot;./mongoose/model/ticketType&quot;); const ticketTypeGroup_1 = require(&quot;./mongoose/model/ticketTypeGroup&quot;); // const debug = createDebug('chevre-domain:*'); /** * Mongoリポジトリー */ class MongoRepository { constructor(connection) { this.ticketTypeModel = connection.model(ticketType_1.default.modelName); this.ticketTypeGroupModel = connection.model(ticketTypeGroup_1.default.modelName); } findByTicketGroupId(params) { return __awaiter(this, void 0, void 0, function* () { const ticketTypeGroup = yield this.ticketTypeGroupModel.findById(params.ticketGroupId).exec() .then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('Ticket type group'); } return doc.toObject(); }); return this.ticketTypeModel.find({ _id: { $in: ticketTypeGroup.ticketTypes } }).exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_reservationNumber.js.html":{"id":"repo_reservationNumber.js.html","title":"Source: repo/reservationNumber.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/reservationNumber.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const createDebug = require(&quot;debug&quot;); const moment = require(&quot;moment-timezone&quot;); const util = require(&quot;util&quot;); const debug = createDebug('chevre-domain:*'); /** * Redisリポジトリー */ class RedisRepository { constructor(redisClient) { this.redisClient = redisClient; } /** * 発行する */ publish(params) { return __awaiter(this, void 0, void 0, function* () { return new Promise((resolve, reject) =&gt; { // 注文番号接頭辞は日付と販売者枝番号 const prefix = util.format('%s-%s', // tslint:disable-next-line:no-magic-numbers params.sellerBranchCode, moment(params.reserveDate).tz('Asia/Tokyo').format('YYMMDD')); const now = moment(); // 一日ごとにカウントアップするので、データ保管期間は一日あれば十分 const TTL = moment(now).add(1, 'day').diff(now, 'seconds'); debug(`TTL:${TTL} seconds`); const key = util.format('%s:%s', RedisRepository.REDIS_KEY_PREFIX, prefix); this.redisClient.multi() .incr(key, debug) .expire(key, TTL) .exec((err, results) =&gt; { debug('results:', results); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore if: please write tests */ if (err instanceof Error) { reject(err); } else { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else: please write tests */ if (Number.isInteger(results[0])) { const no = results[0]; debug('no incremented.', no); resolve(util.format('%s-%s', prefix, // tslint:disable-next-line:no-magic-numbers (`000000${no}`).slice(-6) // 一販売者につき一日あたり最大100000件以内の注文想定 )); } else { // 基本的にありえないフロー reject(new factory.errors.ServiceUnavailable('Reservation number not published')); } } }); }); }); } } RedisRepository.REDIS_KEY_PREFIX = 'chevre:reservationNumber'; exports.RedisRepository = RedisRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_itemAvailability_screeningEvent.js.html":{"id":"repo_itemAvailability_screeningEvent.js.html","title":"Source: repo/itemAvailability/screeningEvent.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/itemAvailability/screeningEvent.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;@chevre/factory&quot;); const createDebug = require(&quot;debug&quot;); const moment = require(&quot;moment&quot;); const debug = createDebug('chevre-domain:*'); /** * 上映イベントに対する座席ごとの在庫状況を保管するリポジトリ */ class RedisRepository { constructor(redisClient) { this.redisClient = redisClient; } /** * 座席をロックする */ lock(lockKey) { return __awaiter(this, void 0, void 0, function* () { debug('locking...', lockKey); const key = `${RedisRepository.KEY_PREFIX}:${lockKey.eventId}`; const value = lockKey.holder; const multi = this.redisClient.multi(); const fields = lockKey.offers.map((offer) =&gt; `${offer.seatSection}:${offer.seatNumber}`); fields.forEach((field) =&gt; { multi.hsetnx(key, field, value); }); const results = yield new Promise((resolve, reject) =&gt; { multi.expireat(key, moment(lockKey.expires).unix()) .exec((err, reply) =&gt; { debug('reply:', reply); if (err !== null) { reject(err); } else { resolve(reply); } }); }); const lockedFields = []; results.slice(0, fields.length).forEach((r, index) =&gt; { if (r === 1) { lockedFields.push(fields[index]); } }); debug('locked fields:', lockedFields); const lockedAll = lockedFields.length === fields.length; debug('lockedAll?', lockedAll); if (!lockedAll) { if (lockedFields.length &gt; 0) { // 全て仮押さえできなければ仮押さえできたものは解除 yield new Promise((resolve, reject) =&gt; { this.redisClient.multi() .hdel(key, lockedFields) .exec((err, reply) =&gt; { debug('reply:', reply); if (err !== null) { reject(err); } else { resolve(); } }); }); } throw new factory.errors.AlreadyInUse('', [], 'Seat number already hold'); } }); } /** * 座席ロックを解除する */ unlock(params) { return __awaiter(this, void 0, void 0, function* () { const key = `${RedisRepository.KEY_PREFIX}:${params.eventId}`; const field = `${params.offer.seatSection}:${params.offer.seatNumber}`; yield new Promise((resolve, reject) =&gt; { this.redisClient.multi() .hdel(key, field) .exec((err, reply) =&gt; { debug('reply:', reply); if (err !== null) { reject(err); } else { resolve(); } }); }); }); } /** * 空席でない座席を検索する */ findUnavailableOffersByEventId(params) { return __awaiter(this, void 0, void 0, function* () { const key = `${RedisRepository.KEY_PREFIX}:${params.eventId}`; return new Promise((resolve, reject) =&gt; { this.redisClient.hgetall(key, (err, reply) =&gt; { debug('reply:', reply); if (err !== null) { reject(err); } else { let offers = []; if (reply !== null) { offers = Object.keys(reply).map((field) =&gt; { const seatSection = field.split(':')[0]; const seatNumber = field.split(':')[1]; return { seatSection, seatNumber }; }); } resolve(offers); } }); }); }); } /** * 保持者を取得する */ getHolder(params) { return __awaiter(this, void 0, void 0, function* () { return new Promise((resolve, reject) =&gt; { const key = `${RedisRepository.KEY_PREFIX}:${params.eventId}`; const field = `${params.offer.seatSection}:${params.offer.seatNumber}`; this.redisClient.hget(key, field, (err, result) =&gt; { debug('result:', err, result); if (err !== null) { reject(err); } else { // tslint:disable-next-line:no-magic-numbers resolve(result); } }); }); }); } } RedisRepository.KEY_PREFIX = 'chevre:itemAvailability:screeningEvent'; exports.RedisRepository = RedisRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_mongoose_model_authentication.js.html":{"id":"repo_mongoose_model_authentication.js.html","title":"Source: repo/mongoose/model/authentication.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/mongoose/model/authentication.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; /** * ログイン認証スキーマ */ const schema = new mongoose.Schema({ token: { type: String, required: true }, owner: { type: String, required: true }, signature: String, locale: String // 使用言語 }, { collection: 'authentications', id: true, read: 'primaryPreferred', safe: safe, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('Authentication', schema); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_mongoose_model_ticketType.js.html":{"id":"repo_mongoose_model_ticketType.js.html","title":"Source: repo/mongoose/model/ticketType.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/mongoose/model/ticketType.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const multilingualString_1 = require(&quot;../schemaTypes/multilingualString&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; /** * 券種スキーマ */ const schema = new mongoose.Schema({ _id: String, name: multilingualString_1.default, description: multilingualString_1.default, notes: multilingualString_1.default, charge: Number // 料金 }, { collection: 'ticketTypes', id: true, read: 'primaryPreferred', safe: safe, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('TicketType', schema); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_mongoose_model_reservation.js.html":{"id":"repo_mongoose_model_reservation.js.html","title":"Source: repo/mongoose/model/reservation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/mongoose/model/reservation.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const bookingAgentSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const reservationForSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const reservedTicketSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const underNameSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * 予約スキーマ */ const schema = new mongoose.Schema({ _id: String, typeOf: { type: String, required: true }, additionalTicketText: String, bookingAgent: bookingAgentSchema, bookingTime: Date, cancelReservationUrl: String, checkinUrl: String, confirmReservationUrl: String, modifiedTime: Date, modifyReservationUrl: String, numSeats: Number, price: Number, priceCurrency: String, programMembershipUsed: String, reservationFor: reservationForSchema, reservationNumber: { type: String, required: true }, reservationStatus: { type: String, required: true }, reservedTicket: reservedTicketSchema, underName: underNameSchema }, { collection: 'reservations', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('Reservation', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_mongoose_model_place.js.html":{"id":"repo_mongoose_model_place.js.html","title":"Source: repo/mongoose/model/place.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/mongoose/model/place.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const multilingualString_1 = require(&quot;../schemaTypes/multilingualString&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const containedInPlaceSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const containsPlaceSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const openingHoursSpecificationSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * 場所スキーマ */ const schema = new mongoose.Schema({ _id: String, typeOf: { type: String, required: true }, name: multilingualString_1.default, description: multilingualString_1.default, address: multilingualString_1.default, branchCode: String, containedInPlace: containedInPlaceSchema, containsPlace: [containsPlaceSchema], maximumAttendeeCapacity: Number, openingHoursSpecification: openingHoursSpecificationSchema, smokingAllowed: Boolean, telephone: String, sameAs: String, url: String, kanaName: String }, { collection: 'places', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); // 劇場検索に使用 schema.index({ branchCode: 1, typeOf: 1 }); exports.default = mongoose.model('Place', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_mongoose_model_ticketTypeGroup.js.html":{"id":"repo_mongoose_model_ticketTypeGroup.js.html","title":"Source: repo/mongoose/model/ticketTypeGroup.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/mongoose/model/ticketTypeGroup.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const multilingualString_1 = require(&quot;../schemaTypes/multilingualString&quot;); const ticketType_1 = require(&quot;./ticketType&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; /** * 券種グループスキーマ */ const schema = new mongoose.Schema({ _id: String, name: multilingualString_1.default, ticketTypes: [{ type: String, ref: ticketType_1.default.modelName, required: true }] }, { collection: 'ticketTypeGroups', id: true, read: 'primaryPreferred', safe: safe, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('TicketTypeGroup', schema); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"repo_mongoose_model_event.js.html":{"id":"repo_mongoose_model_event.js.html","title":"Source: repo/mongoose/model/event.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: repo/mongoose/model/event.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const multilingualString_1 = require(&quot;../schemaTypes/multilingualString&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const locationSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const workPerformedSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const superEventSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * イベント(公演など)スキーマ */ const schema = new mongoose.Schema({ _id: String, typeOf: { type: String, required: true }, identifier: String, name: multilingualString_1.default, description: multilingualString_1.default, doorTime: Date, duration: String, endDate: Date, eventStatus: String, location: locationSchema, startDate: Date, workPerformed: workPerformedSchema, superEvent: superEventSchema, videoFormat: String, subtitleLanguage: String, kanaName: String, alternativeHeadline: String, ticketTypeGroup: String }, { collection: 'events', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); // 上映イベント検索に使用 schema.index({ typeOf: 1, 'superEvent.location.branchCode': 1 }, { partialFilterExpression: { 'superEvent.location.branchCode': { $exists: true } } }); schema.index({ typeOf: 1, 'superEvent.location.identifier': 1, startDate: 1 }, { partialFilterExpression: { 'superEvent.location.identifier': { $exists: true } }, name: 'searchScreeningEventsConditions' }); schema.index({ typeOf: 1, startDate: 1 }); schema.index({ typeOf: 1, endDate: 1 }); // 上映イベント取得に使用 schema.index({ identifier: 1, typeOf: 1 }); exports.default = mongoose.model('Event', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"service.js.html":{"id":"service.js.html","title":"Source: service.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Source: service.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * service module */ const TaskService = require(&quot;./service/task&quot;); const CancelReservationTransactionService = require(&quot;./service/transaction/cancelReservation&quot;); const ReserveTransactionService = require(&quot;./service/transaction/reserve&quot;); const UtilService = require(&quot;./service/util&quot;); exports.task = TaskService; var transaction; (function (transaction) { transaction.cancelReservation = CancelReservationTransactionService; transaction.reserve = ReserveTransactionService; })(transaction = exports.transaction || (exports.transaction = {})); exports.util = UtilService; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Global Members &lt;constant&gt; action_1 リポジトリー Source: repository.js, line 7 &lt;constant&gt; createDebug 予約キャンセル取引サービス Source: service/transaction/cancelReservation.js, line 14 &lt;constant&gt; createDebug 予約取引サービス Source: service/transaction/reserve.js, line 14 default 多言語文字列mongooseスキーマタイプ Source: repo/mongoose/schemaTypes/multilingualString.js, line 6 &lt;constant&gt; factory index module Source: index.js, line 6 &lt;constant&gt; factory タスクサービス Source: service/task.js, line 14 &lt;constant&gt; factory 予約サービス Source: service/reserve.js, line 14 &lt;constant&gt; factory タスクファンクションサービスタスク名ごとに、実行するファンクションをひとつずつ定義しています Source: service/taskFunctions.js, line 15 mongoose MongoDBクライアントmongoose Source: index.js, line 18 Example const promise = domain.mongoose.connect('mongodb://localhost/myapp', { useMongoClient: true }); redis Redis Cacheクライアント Source: index.js, line 29 Example const client = domain.redis.createClient({ host: process.env.REDIS_HOST, port: process.env.REDIS_PORT, password: process.env.REDIS_KEY, tls: { servername: process.env.REDIS_HOST } }); &lt;constant&gt; schema ログイン認証スキーマ Source: repo/mongoose/model/authentication.js, line 8 &lt;constant&gt; schema 券種スキーマ Source: repo/mongoose/model/ticketType.js, line 9 &lt;constant&gt; schema 予約スキーマ Source: repo/mongoose/model/reservation.js, line 28 &lt;constant&gt; schema 場所スキーマ Source: repo/mongoose/model/place.js, line 24 &lt;constant&gt; schema 券種グループスキーマ Source: repo/mongoose/model/ticketTypeGroup.js, line 10 &lt;constant&gt; schema イベント(公演など)スキーマ Source: repo/mongoose/model/event.js, line 24 &lt;constant&gt; sortOrder4executionOfTasks タスク実行時のソート条件 Source: repo/task.js, line 18 &lt;constant&gt; TaskService service module Source: service.js, line 6 Methods abort(intervalInMinutes) abort a taskトライ可能回数が0に達したタスクを実行中止する Parameters: Name Type Description intervalInMinutes 最終トライ日時から何分経過したタスクを中止するか Source: service/task.js, line 91 cancelPendingReservation() 進行中の予約をキャンセルする Source: service/reserve.js, line 50 cancelReservation() 予約をキャンセルする Source: service/reserve.js, line 59 confirm() 取引確定 Source: service/transaction/cancelReservation.js, line 59 confirm() 取引確定 Source: service/transaction/reserve.js, line 136 confirmReservation() 予約を確定する Source: service/reserve.js, line 20 execute(task) execute a taskタスクを実行する Parameters: Name Type Description task タスクオブジェクト Source: service/task.js, line 48 executeByName(taskName) execute a task by taskNameタスク名でタスクをひとつ実行する Parameters: Name Type Description taskName タスク名 Source: service/task.js, line 24 exportTasks() ひとつの取引のタスクをエクスポートする Source: service/transaction/reserve.js, line 167 exportTasks() ひとつの取引のタスクをエクスポートする Source: service/transaction/cancelReservation.js, line 91 exportTasksById() ID指定で取引のタスク出力 Source: service/transaction/reserve.js, line 182 exportTasksById() ID指定で取引のタスク出力 Source: service/transaction/cancelReservation.js, line 106 getPrefectrues() 都道府県リスト Source: service/util.js, line 6 retry(intervalInMinutes) retry tasks in running status実行中ステータスのままになっているタスクをリトライする Parameters: Name Type Description intervalInMinutes 最終トライ日時から何分経過したタスクをリトライするか Source: service/task.js, line 79 start() 取引開始 Source: service/transaction/reserve.js, line 21 start() 取引開始 Source: service/transaction/cancelReservation.js, line 20 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Classes Classes MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository RedisRepository RedisRepository Repository × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Chevre Domain Library for Node.js 元祖興行パッケージオンラインチケットシステムのドメインモデルをnode.jsで使いやすいようにまとめたパッケージです。 Table of contents Usage Code Samples License Usagenpm install --save @chevre/domainconst chevre = require(&quot;@chevre/chevredomain&quot;);前提として、mongooseでdefault connectionを確保することと、redis情報をセットすることが必要。 mongoose default connection chevre.mongoose.connect();Environment variables Name Required Value Purpose DEBUG false chevre-domain:* Debug CHEVRE_PERFORMANCE_STATUSES_REDIS_PORT true パフォーマンス空席状況保管RedisCache接続情報 CHEVRE_PERFORMANCE_STATUSES_REDIS_HOST true パフォーマンス空席状況保管RedisCache接続情報 CHEVRE_PERFORMANCE_STATUSES_REDIS_KEY true パフォーマンス空席状況保管RedisCache接続情報 Code SamplesCode sample are here. LicenseISC × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"MongoRepository.html":{"id":"MongoRepository.html","title":"Class: MongoRepository","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Class: MongoRepository MongoRepository 取引Mongoリポジトリー new MongoRepository() Source: repo/transaction.js, line 17 Methods cancel() 取引を中止する Source: repo/transaction.js, line 86 cancel() アクション中止 Source: repo/action.js, line 53 complete() アクション完了 Source: repo/action.js, line 33 confirm() 取引を確定する Source: repo/transaction.js, line 51 findById() IDで取引を取得する Source: repo/transaction.js, line 32 findById() IDで取得する Source: repo/action.js, line 90 findById() IDでイベントを取得する Source: repo/event.js, line 241 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 63 giveUp() アクション失敗 Source: repo/action.js, line 70 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 161 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 135 saveMovieTheater(movieTheater) 劇場を保管する Parameters: Name Type Description movieTheater movieTheater object Source: repo/place.js, line 32 saveScreeningEvent() 個々の上映イベントを保管する Source: repo/event.js, line 49 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 25 search(searchConditions) アクションを検索する Parameters: Name Type Description searchConditions 検索条件 Source: repo/action.js, line 108 search(conditions) 取引を検索する Parameters: Name Type Description conditions 検索条件 Source: repo/transaction.js, line 177 searchMovieTheaters(searchConditions) 劇場検索 Parameters: Name Type Description searchConditions 検索条件 Source: repo/place.js, line 43 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 23 searchScreeningEvents() 個々の上映イベントを検索する Source: repo/event.js, line 73 searchScreeningEventSeries() 上映イベントを検索する Source: repo/event.js, line 166 setTasksExportedById(transactionId) set task status exported by transaction idIDでタスクをエクスポート済に変更する Parameters: Name Type Description transactionId transaction id Source: repo/transaction.js, line 150 start() 取引を開始する Source: repo/transaction.js, line 24 start() アクション開始 Source: repo/action.js, line 25 startExportTasks(typeOf, status) タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Parameters: Name Type Description typeOf 取引タイプ status 取引ステータス Source: repo/transaction.js, line 122 Class: MongoRepository MongoRepository タスクレポジトリー new MongoRepository() Source: repo/task.js, line 25 Methods cancel() 取引を中止する Source: repo/transaction.js, line 86 cancel() アクション中止 Source: repo/action.js, line 53 complete() アクション完了 Source: repo/action.js, line 33 confirm() 取引を確定する Source: repo/transaction.js, line 51 findById() IDで取引を取得する Source: repo/transaction.js, line 32 findById() IDで取得する Source: repo/action.js, line 90 findById() IDでイベントを取得する Source: repo/event.js, line 241 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 63 giveUp() アクション失敗 Source: repo/action.js, line 70 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 161 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 135 saveMovieTheater(movieTheater) 劇場を保管する Parameters: Name Type Description movieTheater movieTheater object Source: repo/place.js, line 32 saveScreeningEvent() 個々の上映イベントを保管する Source: repo/event.js, line 49 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 25 search(searchConditions) アクションを検索する Parameters: Name Type Description searchConditions 検索条件 Source: repo/action.js, line 108 search(conditions) 取引を検索する Parameters: Name Type Description conditions 検索条件 Source: repo/transaction.js, line 177 searchMovieTheaters(searchConditions) 劇場検索 Parameters: Name Type Description searchConditions 検索条件 Source: repo/place.js, line 43 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 23 searchScreeningEvents() 個々の上映イベントを検索する Source: repo/event.js, line 73 searchScreeningEventSeries() 上映イベントを検索する Source: repo/event.js, line 166 setTasksExportedById(transactionId) set task status exported by transaction idIDでタスクをエクスポート済に変更する Parameters: Name Type Description transactionId transaction id Source: repo/transaction.js, line 150 start() 取引を開始する Source: repo/transaction.js, line 24 start() アクション開始 Source: repo/action.js, line 25 startExportTasks(typeOf, status) タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Parameters: Name Type Description typeOf 取引タイプ status 取引ステータス Source: repo/transaction.js, line 122 Class: MongoRepository MongoRepository イベントリポジトリー new MongoRepository() Source: repo/event.js, line 18 Methods cancel() 取引を中止する Source: repo/transaction.js, line 86 cancel() アクション中止 Source: repo/action.js, line 53 complete() アクション完了 Source: repo/action.js, line 33 confirm() 取引を確定する Source: repo/transaction.js, line 51 findById() IDで取引を取得する Source: repo/transaction.js, line 32 findById() IDで取得する Source: repo/action.js, line 90 findById() IDでイベントを取得する Source: repo/event.js, line 241 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 63 giveUp() アクション失敗 Source: repo/action.js, line 70 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 161 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 135 saveMovieTheater(movieTheater) 劇場を保管する Parameters: Name Type Description movieTheater movieTheater object Source: repo/place.js, line 32 saveScreeningEvent() 個々の上映イベントを保管する Source: repo/event.js, line 49 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 25 search(searchConditions) アクションを検索する Parameters: Name Type Description searchConditions 検索条件 Source: repo/action.js, line 108 search(conditions) 取引を検索する Parameters: Name Type Description conditions 検索条件 Source: repo/transaction.js, line 177 searchMovieTheaters(searchConditions) 劇場検索 Parameters: Name Type Description searchConditions 検索条件 Source: repo/place.js, line 43 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 23 searchScreeningEvents() 個々の上映イベントを検索する Source: repo/event.js, line 73 searchScreeningEventSeries() 上映イベントを検索する Source: repo/event.js, line 166 setTasksExportedById(transactionId) set task status exported by transaction idIDでタスクをエクスポート済に変更する Parameters: Name Type Description transactionId transaction id Source: repo/transaction.js, line 150 start() 取引を開始する Source: repo/transaction.js, line 24 start() アクション開始 Source: repo/action.js, line 25 startExportTasks(typeOf, status) タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Parameters: Name Type Description typeOf 取引タイプ status 取引ステータス Source: repo/transaction.js, line 122 Class: MongoRepository MongoRepository 場所リポジトリー new MongoRepository() Source: repo/place.js, line 24 Methods cancel() 取引を中止する Source: repo/transaction.js, line 86 cancel() アクション中止 Source: repo/action.js, line 53 complete() アクション完了 Source: repo/action.js, line 33 confirm() 取引を確定する Source: repo/transaction.js, line 51 findById() IDで取引を取得する Source: repo/transaction.js, line 32 findById() IDで取得する Source: repo/action.js, line 90 findById() IDでイベントを取得する Source: repo/event.js, line 241 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 63 giveUp() アクション失敗 Source: repo/action.js, line 70 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 161 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 135 saveMovieTheater(movieTheater) 劇場を保管する Parameters: Name Type Description movieTheater movieTheater object Source: repo/place.js, line 32 saveScreeningEvent() 個々の上映イベントを保管する Source: repo/event.js, line 49 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 25 search(searchConditions) アクションを検索する Parameters: Name Type Description searchConditions 検索条件 Source: repo/action.js, line 108 search(conditions) 取引を検索する Parameters: Name Type Description conditions 検索条件 Source: repo/transaction.js, line 177 searchMovieTheaters(searchConditions) 劇場検索 Parameters: Name Type Description searchConditions 検索条件 Source: repo/place.js, line 43 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 23 searchScreeningEvents() 個々の上映イベントを検索する Source: repo/event.js, line 73 searchScreeningEventSeries() 上映イベントを検索する Source: repo/event.js, line 166 setTasksExportedById(transactionId) set task status exported by transaction idIDでタスクをエクスポート済に変更する Parameters: Name Type Description transactionId transaction id Source: repo/transaction.js, line 150 start() 取引を開始する Source: repo/transaction.js, line 24 start() アクション開始 Source: repo/action.js, line 25 startExportTasks(typeOf, status) タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Parameters: Name Type Description typeOf 取引タイプ status 取引ステータス Source: repo/transaction.js, line 122 Class: MongoRepository MongoRepository 予約リポジトリー new MongoRepository() Source: repo/reservation.js, line 16 Methods cancel() 取引を中止する Source: repo/transaction.js, line 86 cancel() アクション中止 Source: repo/action.js, line 53 complete() アクション完了 Source: repo/action.js, line 33 confirm() 取引を確定する Source: repo/transaction.js, line 51 findById() IDで取引を取得する Source: repo/transaction.js, line 32 findById() IDで取得する Source: repo/action.js, line 90 findById() IDでイベントを取得する Source: repo/event.js, line 241 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 63 giveUp() アクション失敗 Source: repo/action.js, line 70 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 161 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 135 saveMovieTheater(movieTheater) 劇場を保管する Parameters: Name Type Description movieTheater movieTheater object Source: repo/place.js, line 32 saveScreeningEvent() 個々の上映イベントを保管する Source: repo/event.js, line 49 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 25 search(searchConditions) アクションを検索する Parameters: Name Type Description searchConditions 検索条件 Source: repo/action.js, line 108 search(conditions) 取引を検索する Parameters: Name Type Description conditions 検索条件 Source: repo/transaction.js, line 177 searchMovieTheaters(searchConditions) 劇場検索 Parameters: Name Type Description searchConditions 検索条件 Source: repo/place.js, line 43 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 23 searchScreeningEvents() 個々の上映イベントを検索する Source: repo/event.js, line 73 searchScreeningEventSeries() 上映イベントを検索する Source: repo/event.js, line 166 setTasksExportedById(transactionId) set task status exported by transaction idIDでタスクをエクスポート済に変更する Parameters: Name Type Description transactionId transaction id Source: repo/transaction.js, line 150 start() 取引を開始する Source: repo/transaction.js, line 24 start() アクション開始 Source: repo/action.js, line 25 startExportTasks(typeOf, status) タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Parameters: Name Type Description typeOf 取引タイプ status 取引ステータス Source: repo/transaction.js, line 122 Class: MongoRepository MongoRepository アクションリポジトリー new MongoRepository() Source: repo/action.js, line 18 Methods cancel() 取引を中止する Source: repo/transaction.js, line 86 cancel() アクション中止 Source: repo/action.js, line 53 complete() アクション完了 Source: repo/action.js, line 33 confirm() 取引を確定する Source: repo/transaction.js, line 51 findById() IDで取引を取得する Source: repo/transaction.js, line 32 findById() IDで取得する Source: repo/action.js, line 90 findById() IDでイベントを取得する Source: repo/event.js, line 241 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 63 giveUp() アクション失敗 Source: repo/action.js, line 70 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 161 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 135 saveMovieTheater(movieTheater) 劇場を保管する Parameters: Name Type Description movieTheater movieTheater object Source: repo/place.js, line 32 saveScreeningEvent() 個々の上映イベントを保管する Source: repo/event.js, line 49 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 25 search(searchConditions) アクションを検索する Parameters: Name Type Description searchConditions 検索条件 Source: repo/action.js, line 108 search(conditions) 取引を検索する Parameters: Name Type Description conditions 検索条件 Source: repo/transaction.js, line 177 searchMovieTheaters(searchConditions) 劇場検索 Parameters: Name Type Description searchConditions 検索条件 Source: repo/place.js, line 43 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 23 searchScreeningEvents() 個々の上映イベントを検索する Source: repo/event.js, line 73 searchScreeningEventSeries() 上映イベントを検索する Source: repo/event.js, line 166 setTasksExportedById(transactionId) set task status exported by transaction idIDでタスクをエクスポート済に変更する Parameters: Name Type Description transactionId transaction id Source: repo/transaction.js, line 150 start() 取引を開始する Source: repo/transaction.js, line 24 start() アクション開始 Source: repo/action.js, line 25 startExportTasks(typeOf, status) タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Parameters: Name Type Description typeOf 取引タイプ status 取引ステータス Source: repo/transaction.js, line 122 Class: MongoRepository MongoRepository Mongoリポジトリー new MongoRepository() Source: repo/ticketType.js, line 18 Methods cancel() 取引を中止する Source: repo/transaction.js, line 86 cancel() アクション中止 Source: repo/action.js, line 53 complete() アクション完了 Source: repo/action.js, line 33 confirm() 取引を確定する Source: repo/transaction.js, line 51 findById() IDで取引を取得する Source: repo/transaction.js, line 32 findById() IDで取得する Source: repo/action.js, line 90 findById() IDでイベントを取得する Source: repo/event.js, line 241 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 63 giveUp() アクション失敗 Source: repo/action.js, line 70 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 161 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 135 saveMovieTheater(movieTheater) 劇場を保管する Parameters: Name Type Description movieTheater movieTheater object Source: repo/place.js, line 32 saveScreeningEvent() 個々の上映イベントを保管する Source: repo/event.js, line 49 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 25 search(searchConditions) アクションを検索する Parameters: Name Type Description searchConditions 検索条件 Source: repo/action.js, line 108 search(conditions) 取引を検索する Parameters: Name Type Description conditions 検索条件 Source: repo/transaction.js, line 177 searchMovieTheaters(searchConditions) 劇場検索 Parameters: Name Type Description searchConditions 検索条件 Source: repo/place.js, line 43 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 23 searchScreeningEvents() 個々の上映イベントを検索する Source: repo/event.js, line 73 searchScreeningEventSeries() 上映イベントを検索する Source: repo/event.js, line 166 setTasksExportedById(transactionId) set task status exported by transaction idIDでタスクをエクスポート済に変更する Parameters: Name Type Description transactionId transaction id Source: repo/transaction.js, line 150 start() 取引を開始する Source: repo/transaction.js, line 24 start() アクション開始 Source: repo/action.js, line 25 startExportTasks(typeOf, status) タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Parameters: Name Type Description typeOf 取引タイプ status 取引ステータス Source: repo/transaction.js, line 122 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"RedisRepository.html":{"id":"RedisRepository.html","title":"Class: RedisRepository","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Class: RedisRepository RedisRepository Redisリポジトリー new RedisRepository() Source: repo/reservationNumber.js, line 19 Methods findUnavailableOffersByEventId() 空席でない座席を検索する Source: repo/itemAvailability/screeningEvent.js, line 102 getHolder() 保持者を取得する Source: repo/itemAvailability/screeningEvent.js, line 129 lock() 座席をロックする Source: repo/itemAvailability/screeningEvent.js, line 25 publish() 発行する Source: repo/reservationNumber.js, line 26 unlock() 座席ロックを解除する Source: repo/itemAvailability/screeningEvent.js, line 80 Class: RedisRepository RedisRepository 上映イベントに対する座席ごとの在庫状況を保管するリポジトリ new RedisRepository() Source: repo/itemAvailability/screeningEvent.js, line 18 Methods findUnavailableOffersByEventId() 空席でない座席を検索する Source: repo/itemAvailability/screeningEvent.js, line 102 getHolder() 保持者を取得する Source: repo/itemAvailability/screeningEvent.js, line 129 lock() 座席をロックする Source: repo/itemAvailability/screeningEvent.js, line 25 publish() 発行する Source: repo/reservationNumber.js, line 26 unlock() 座席ロックを解除する Source: repo/itemAvailability/screeningEvent.js, line 80 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "},"Repository.html":{"id":"Repository.html","title":"Class: Repository","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1cancelPendingReservationcancelReservationconfirmconfirmReservationcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdfactorygetPrefectruesmongooseredisretryschemasortOrder4executionOfTasksstartTaskService Class: Repository Repository 場所抽象リポジトリー new Repository() Source: repo/place.js, line 18 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Aug 15th 2018 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
